<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Evolution - 5 Ships Update</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
        
        /* UI LAYOUT */
        #ui {
            display: none;
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        #score {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        #ability-status {
            font-size: 18px;
            margin-top: 5px;
            font-weight: bold;
        }
        .ready { color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        .cooldown { color: #555; }
        .passive { color: #ffa500; }
        
        /* MENU LAYOUT */
        #menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            overflow-y: auto; /* Allow scroll if screen is small */
        }
        
        .ship-container {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping for 5 ships */
            justify-content: center;
            max-width: 1200px;
        }
        
        .ship-card {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px;
            width: 180px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .ship-card:hover {
            transform: scale(1.05);
            border-color: #fff;
            background: #252525;
        }

        .ship-card h2 { margin: 0 0 5px 0; font-size: 18px; }
        .ship-card p { font-size: 12px; color: #aaa; margin: 5px 0; }
        .ship-preview {
            width: 40px; height: 40px;
            margin: 10px auto;
            border-radius: 50%;
            border: 1px dashed #555;
            position: relative;
        }
        
        /* PREVIEW SHAPES */
        .shape-vanguard {
            width: 0; height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid white;
            position: absolute; top: 12px; left: 12px;
        }
        .shape-anchor {
            width: 16px; height: 16px;
            background: orange;
            position: absolute; top: 12px; left: 12px;
            transform: rotate(45deg);
        }
        .shape-interceptor {
            width: 0; height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 20px solid cyan;
            position: absolute; top: 10px; left: 15px;
        }
        .shape-phantom {
            width: 0; height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid #d630ff;
            position: absolute; top: 12px; left: 12px;
            opacity: 0.7;
        }
        .shape-acrobat {
            width: 0; height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 18px solid #55efc4;
            position: absolute; top: 11px; left: 14px;
        }

        /* GAME OVER */
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border: 2px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(255, 50, 50, 0.3);
            z-index: 30;
        }
        .button-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }
        button {
            background: white;
            color: black;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
        }
        button:hover { transform: scale(1.05); }
    </style>
</head>
<body>

<div id="menu">
    <h1>SELECT YOUR SHIP</h1>
    <div class="ship-container">
        <div class="ship-card" onclick="startGame(0)">
            <h2>VANGUARD</h2>
            <div class="ship-preview"><div class="shape-vanguard"></div></div>
            <p style="color:white">Ability: Shield</p>
            <p>Become invincible for 1s.</p>
        </div>

        <div class="ship-card" onclick="startGame(1)">
            <h2>ANCHOR</h2>
            <div class="ship-preview"><div class="shape-anchor"></div></div>
            <p style="color:orange">Passive: Heavy</p>
            <p>25% Gravity Resistance.</p>
        </div>

        <div class="ship-card" onclick="startGame(2)">
            <h2>INTERCEPTOR</h2>
            <div class="ship-preview"><div class="shape-interceptor"></div></div>
            <p style="color:cyan">Ability: Turbo</p>
            <p>Simple forward speed boost.</p>
        </div>

        <div class="ship-card" onclick="startGame(3)">
            <h2>PHANTOM</h2>
            <div class="ship-preview"><div class="shape-phantom"></div></div>
            <p style="color:#d630ff">Ability: Phase Dash</p>
            <p>Dash through objects safely.</p>
        </div>

        <div class="ship-card" onclick="startGame(4)">
            <h2>ACROBAT</h2>
            <div class="ship-preview"><div class="shape-acrobat"></div></div>
            <p style="color:#55efc4">Passive: Agility</p>
            <p>Double turn speed & control.</p>
        </div>
    </div>
</div>

<div id="ui">
    <div id="score">Time Survived: 0s</div>
    <div id="ability-status" class="ready">ABILITY: READY</div>
    <div id="controls-hint">WASD to Move | SPACE for Ability</div>
</div>

<div id="game-over">
    <h1 id="death-reason">YOU DIED</h1>
    <p id="final-score">Time: 0s</p>
    <div class="button-row">
        <button onclick="restartGame()">Play Again</button>
        <button onclick="resetMenu()">Main Menu</button>
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration ---
    let width, height;
    
    // Global Speed Multiplier
    const GAME_SPEED_MULTIPLIER = 0.5;

    // Game State
    let gameState = 'MENU'; 
    let startTime = 0;
    let lastShipType = 0; // Remembers selection for "Play Again"
    
    // Input
    const keys = {
        w: false, a: false, s: false, d: false, " ": false,
        ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
    };

    // Entities
    let player;
    let entities = [];
    let particles = [];
    let projectiles = [];
    let starsBg = [];

    // --- Classes ---

    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { this.x += v.x; this.y += v.y; }
        sub(v) { this.x -= v.x; this.y -= v.y; }
        mult(n) { this.x *= n; this.y *= n; }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() {
            let m = this.mag();
            if (m !== 0) this.mult(1 / m);
        }
    }

    class Player {
        constructor(shipType) {
            this.pos = new Vector(width / 2, height / 2);
            this.vel = new Vector(0, 0);
            this.acc = new Vector(0, 0);
            this.angle = -Math.PI / 2;
            this.radius = 10;
            this.friction = 0.99;
            this.turnSpeed = 0.08 * GAME_SPEED_MULTIPLIER;
            this.thrust = 0.30 * GAME_SPEED_MULTIPLIER;
            this.dead = false;
            
            // 0: Vanguard, 1: Anchor, 2: Interceptor, 3: Phantom, 4: Acrobat
            this.shipType = shipType; 

            // Ability Variables
            this.abilityActive = false;
            this.abilityTimer = 0;
            this.cooldownTimer = 0;

            // --- SHIP STATS ---
            if (this.shipType === 1) { // Anchor
                this.friction = 0.98;
                this.turnSpeed = 0.06 * GAME_SPEED_MULTIPLIER;
            }
            if (this.shipType === 2) { // Interceptor
                this.turnSpeed = 0.1 * GAME_SPEED_MULTIPLIER;
                this.friction = 0.995;
            }
            if (this.shipType === 4) { // Acrobat (New Maneuverable)
                this.turnSpeed = 0.16 * GAME_SPEED_MULTIPLIER; // Double turn speed
                this.thrust = 0.45 * GAME_SPEED_MULTIPLIER;    // Higher acceleration
                this.friction = 0.95; // High drag for tight turns/stopping
            }
        }

        update() {
            if (this.dead) return;

            // --- ABILITY LOGIC ---
            
            // SHIP 0: SHIELD
            if (this.shipType === 0) {
                if (keys[" "] && this.cooldownTimer <= 0 && !this.abilityActive) {
                    this.abilityActive = true;
                    this.abilityTimer = 60 / GAME_SPEED_MULTIPLIER; 
                    this.cooldownTimer = 180 / GAME_SPEED_MULTIPLIER;
                }
                if (this.abilityActive) {
                    this.abilityTimer--;
                    if (this.abilityTimer <= 0) this.abilityActive = false;
                }
            }

            // SHIP 2: SPEED BOOST
            if (this.shipType === 2) {
                if (keys[" "] && this.cooldownTimer <= 0) {
                    let boost = new Vector(Math.cos(this.angle), Math.sin(this.angle));
                    boost.mult(15 * GAME_SPEED_MULTIPLIER);
                    this.vel.add(boost);
                    for(let i=0; i<10; i++) particles.push(new Particle(this.pos.x, this.pos.y, -boost.x*0.5, -boost.y*0.5, '#00ffff', 30));
                    this.cooldownTimer = 120 / GAME_SPEED_MULTIPLIER; 
                }
            }

            // SHIP 3: PHASE DASH (New)
            if (this.shipType === 3) {
                if (keys[" "] && this.cooldownTimer <= 0 && !this.abilityActive) {
                    this.abilityActive = true; // Invincible/Intangible
                    
                    // Dash Force
                    let dash = new Vector(Math.cos(this.angle), Math.sin(this.angle));
                    dash.mult(25 * GAME_SPEED_MULTIPLIER); // Super fast
                    this.vel = dash; // Set velocity directly (snappy dash)

                    this.abilityTimer = 15 / GAME_SPEED_MULTIPLIER; // Short dash (0.25s)
                    this.cooldownTimer = 180 / GAME_SPEED_MULTIPLIER; // 3s recharge (Same as Shield)
                    
                    // Particles
                    for(let i=0; i<15; i++) particles.push(new Particle(this.pos.x, this.pos.y, (Math.random()-0.5)*5, (Math.random()-0.5)*5, '#d630ff', 40));
                }

                if (this.abilityActive) {
                    this.abilityTimer--;
                    if (this.abilityTimer <= 0) {
                        this.abilityActive = false;
                        this.vel.mult(0.2); // Stop momentum after dash
                    }
                }
            }

            // Cooldown handling
            if (this.cooldownTimer > 0) this.cooldownTimer--;

            // UI Update
            const statusDiv = document.getElementById('ability-status');
            
            if (this.shipType === 1 || this.shipType === 4) {
                let txt = this.shipType === 1 ? "PASSIVE: GRAVITY RESIST" : "PASSIVE: HIGH AGILITY";
                statusDiv.innerText = txt;
                statusDiv.className = "passive";
            } else {
                if (this.abilityActive) {
                    let activeText = this.shipType === 3 ? "PHASING!" : "SHIELD ACTIVE!";
                    statusDiv.innerText = activeText;
                    statusDiv.className = "ready";
                    statusDiv.style.color = "white";
                } else if (this.cooldownTimer > 0) {
                    let secondsLeft = Math.ceil((this.cooldownTimer * GAME_SPEED_MULTIPLIER) / 60);
                    statusDiv.innerText = `COOLDOWN (${secondsLeft})`;
                    statusDiv.className = "cooldown";
                } else {
                    let name = "ABILITY";
                    if (this.shipType === 0) name = "SHIELD";
                    if (this.shipType === 2) name = "BOOST";
                    if (this.shipType === 3) name = "PHASE";
                    statusDiv.innerText = `${name}: READY (SPACE)`;
                    statusDiv.className = "ready";
                }
            }


            // Rotation
            if (keys.a || keys.ArrowLeft) this.angle -= this.turnSpeed;
            if (keys.d || keys.ArrowRight) this.angle += this.turnSpeed;

            // Thrust
            if (keys.w || keys.ArrowUp) {
                this.acc.x = Math.cos(this.angle) * this.thrust;
                this.acc.y = Math.sin(this.angle) * this.thrust;
                
                let pColor = '#ffa500';
                if(this.shipType === 2) pColor = '#00ffff';
                if(this.shipType === 3) pColor = '#d630ff';
                if(this.shipType === 4) pColor = '#55efc4';

                for(let i=0; i<2; i++) {
                    particles.push(new Particle(
                        this.pos.x - Math.cos(this.angle) * 10 + (Math.random()-0.5)*5,
                        this.pos.y - Math.sin(this.angle) * 10 + (Math.random()-0.5)*5,
                        -Math.cos(this.angle) * (2 * GAME_SPEED_MULTIPLIER),
                        -Math.sin(this.angle) * (2 * GAME_SPEED_MULTIPLIER),
                        pColor, 20
                    ));
                }
            } else if (keys.s || keys.ArrowDown) {
                this.acc.x = -Math.cos(this.angle) * (this.thrust * 0.5);
                this.acc.y = -Math.sin(this.angle) * (this.thrust * 0.5);
            } else {
                this.acc.x = 0;
                this.acc.y = 0;
            }

            // Apply Physics
            this.vel.add(this.acc);
            this.vel.mult(this.friction);
            this.pos.add(this.vel);

            // Screen Wrap
            if (this.pos.x < 0) this.pos.x = width;
            if (this.pos.x > width) this.pos.x = 0;
            if (this.pos.y < 0) this.pos.y = height;
            if (this.pos.y > height) this.pos.y = 0;
        }

        draw() {
            if (this.dead) return;
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.angle);

            // Visuals based on Ship Type

            if (this.shipType === 0) { // VANGUARD (Triangle)
                if (this.abilityActive) {
                    ctx.save();
                    ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.shadowBlur = 15; ctx.shadowColor = '#00ffff';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 15, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.1)'; ctx.fill(); ctx.restore();
                }
                ctx.beginPath();
                ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10);
                ctx.closePath(); ctx.strokeStyle = 'white';
            } 
            else if (this.shipType === 1) { // ANCHOR (Boxy)
                ctx.beginPath();
                ctx.moveTo(12, -8); ctx.lineTo(12, 8); ctx.lineTo(-10, 12); ctx.lineTo(-10, -12);
                ctx.closePath(); ctx.strokeStyle = 'orange';
            }
            else if (this.shipType === 2) { // INTERCEPTOR (Needle)
                ctx.beginPath();
                ctx.moveTo(20, 0); ctx.lineTo(-15, 6); ctx.lineTo(-10, 0); ctx.lineTo(-15, -6);
                ctx.closePath(); ctx.strokeStyle = 'cyan';
            }
            else if (this.shipType === 3) { // PHANTOM (Ghostly)
                ctx.globalAlpha = this.abilityActive ? 0.4 : 1.0; // Transparent when phasing
                ctx.beginPath();
                ctx.moveTo(15, 0); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8);
                ctx.closePath(); ctx.strokeStyle = '#d630ff';
                if (this.abilityActive) {
                    ctx.shadowBlur = 20; ctx.shadowColor = '#d630ff';
                }
            }
            else if (this.shipType === 4) { // ACROBAT (Dart)
                ctx.beginPath();
                ctx.moveTo(15, 0); ctx.lineTo(-8, 12); ctx.lineTo(-4, 0); ctx.lineTo(-8, -12);
                ctx.closePath(); ctx.strokeStyle = '#55efc4';
            }

            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fill();

            ctx.restore();
        }
    }

    class Entity {
        constructor(x, y, radius, type) {
            this.pos = new Vector(x, y);
            
            let baseSpeed = (type === 0) ? (Math.random() * 3 + 1.5) : (Math.random() * 2 + 0.5);
            let speed = baseSpeed * GAME_SPEED_MULTIPLIER;
            
            let dir = Math.random() * Math.PI * 2;
            this.vel = new Vector(Math.cos(dir) * speed, Math.sin(dir) * speed);
            this.radius = radius;
            this.mass = radius; 
            this.type = type; 
            this.markedForDeletion = false;
            
            this.points = [];
            let sides = Math.floor(Math.random() * 5) + 5;
            for (let i = 0; i < sides; i++) {
                let angle = (i / sides) * Math.PI * 2;
                let r = this.radius * (0.8 + Math.random() * 0.4);
                this.points.push({x: Math.cos(angle) * r, y: Math.sin(angle) * r});
            }

            this.age = 0;
            this.angle = 0;
            this.spinSpeed = (Math.random() - 0.5) * 0.05 * GAME_SPEED_MULTIPLIER;
            
            this.baseBeamAngle = Math.random() * Math.PI * 2; 
            this.effectiveBeamAngle = 0;
            this.windupDuration = 120 / GAME_SPEED_MULTIPLIER; 
            this.warningDuration = 120 / GAME_SPEED_MULTIPLIER; 
            this.fireDuration = 60 / GAME_SPEED_MULTIPLIER; 
            this.beamState = 'WINDUP';
            this.beamTimer = 0;
            
            this.shootTimer = 0;
        }

        getVisualRadius() {
            if (this.type === 0) return this.radius; 
            if (this.type === 1) return this.radius * 0.6; 
            if (this.type === 2) return this.radius * 0.5; 
            if (this.type === 3) return this.radius * 0.6; 
            if (this.type === 4) return this.radius * 0.5; 
            return this.radius;
        }

        update() {
            this.age++;
            this.angle += this.spinSpeed;

            if (this.type >= 1) { 
                this.vel.mult(0.95); 
            }
            
            this.pos.add(this.vel);

            let buffer = this.radius;
            if (this.pos.x < -buffer) this.pos.x = width + buffer;
            if (this.pos.x > width + buffer) this.pos.x = -buffer;
            if (this.pos.y < -buffer) this.pos.y = height + buffer;
            if (this.pos.y > height + buffer) this.pos.y = -buffer;

            if (this.radius > 45 && this.type === 0) this.evolve(1);
            if (this.radius > 65 && this.type === 1) this.evolve(2);
            if (this.radius > 85 && this.type === 2) this.evolve(3);
            if (this.radius > 120 && this.type === 3) this.supernovaExplode(); 

            if (this.type === 2) { 
                // --- CHANGED: FASTER FREQ, TIGHTER AMP ---
                const wobble = Math.sin(this.age * 0.30 * GAME_SPEED_MULTIPLIER) * 0.3; 
                this.effectiveBeamAngle = this.baseBeamAngle + wobble; 

                this.beamTimer++;

                if (this.beamState === 'WINDUP') {
                    if (this.beamTimer > this.windupDuration) {
                        this.beamState = 'WARNING';
                        this.beamTimer = 0;
                    }
                } else if (this.beamState === 'WARNING') {
                    if (this.beamTimer > this.warningDuration) {
                        this.beamState = 'FIRE';
                        this.beamTimer = 0;
                    }
                } else if (this.beamState === 'FIRE') {
                    // Check Collision
                    let isProtected = (player.shipType === 0 && player.abilityActive) || (player.shipType === 3 && player.abilityActive);
                    
                    if (!player.dead && !isProtected) {
                        let dx = player.pos.x - this.pos.x;
                        let dy = player.pos.y - this.pos.y;
                        let dist = Math.sqrt(dx*dx + dy*dy);
                        let angleToPlayer = Math.atan2(dy, dx);
                        
                        let angleDiff = Math.abs(Math.atan2(
                            Math.sin(angleToPlayer - this.effectiveBeamAngle), 
                            Math.cos(angleToPlayer - this.effectiveBeamAngle)
                        ));
                        
                        let oppositeBeamAngle = this.effectiveBeamAngle + Math.PI;
                        let oppositeAngleDiff = Math.abs(Math.atan2(
                            Math.sin(angleToPlayer - oppositeBeamAngle), 
                            Math.cos(angleToPlayer - oppositeBeamAngle)
                        ));

                        if (dist < 2000 && (angleDiff < 0.1 || oppositeAngleDiff < 0.1)) {
                             gameOver("Vaporized by Pulsar Beam");
                        }
                    }

                    if (this.beamTimer > this.fireDuration) {
                        this.beamState = 'WINDUP';
                        this.beamTimer = 0;
                    }
                }
            }
            if (this.type === 3) { 
                this.shootTimer++;
                if (this.shootTimer > 20 / GAME_SPEED_MULTIPLIER) {
                    this.shootTimer = 0;
                    for(let i=0; i<10; i++) {
                        let angle = Math.random() * Math.PI * 2;
                        projectiles.push(new Projectile(this.pos.x, this.pos.y, angle));
                    }
                }
                this.visualRadius = this.radius + Math.sin(this.age * 0.1) * 5;
            } else {
                this.visualRadius = this.radius;
            }

            if (this.type === 4) { 
                this.radius += 0.05 * GAME_SPEED_MULTIPLIER; 
            }
        }

        evolve(newType) {
            this.type = newType;
            if (newType === 1) this.mass = 100;
            if (newType === 2) {
                let dx = this.pos.x - player.pos.x;
                let dy = this.pos.y - player.pos.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                
                let isProtected = (player.shipType === 0 && player.abilityActive) || (player.shipType === 3 && player.abilityActive);

                if (dist < 150 && !isProtected) { 
                    gameOver("Vaporized by Pulsar Core Collapse");
                }
                this.mass = 200;
                this.beamState = 'WINDUP';
                this.beamTimer = 0;
                this.baseBeamAngle = Math.random() * Math.PI * 2;
            }
            if (newType === 3) this.mass = 400;
        }

        supernovaExplode() {
            this.markedForDeletion = true; 
            for(let i=0; i<50; i++) {
                let ang = Math.random() * Math.PI * 2;
                let spd = Math.random() * 10 * GAME_SPEED_MULTIPLIER;
                particles.push(new Particle(this.pos.x, this.pos.y, Math.cos(ang)*spd, Math.sin(ang)*spd, '#ff0000', 60));
            }
            let dx = this.pos.x - player.pos.x;
            let dy = this.pos.y - player.pos.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            let isProtected = (player.shipType === 0 && player.abilityActive) || (player.shipType === 3 && player.abilityActive);
            
            if (dist < 300 && !isProtected) {
                gameOver("Incinerated by Supernova");
            }
            let bh = new Entity(this.pos.x, this.pos.y, 20, 4); 
            entities.push(bh);
        }

        draw() {
            ctx.save();
            ctx.translate(this.pos.x, this.pos.y);
            ctx.rotate(this.angle);

            if (this.type === 0) { // Asteroid
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (let i = 1; i < this.points.length; i++) {
                    ctx.lineTo(this.points[i].x, this.points[i].y);
                }
                ctx.closePath();
                ctx.stroke();
            }
            else if (this.type === 1) { // Star
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#fdcb6e';
                ctx.fillStyle = '#ffeaa7';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI*2);
                ctx.fill();
            }
            else if (this.type === 2) { // Pulsar
                ctx.rotate(this.age * 0.2 * GAME_SPEED_MULTIPLIER); 
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#0984e3';
                ctx.fillStyle = '#74b9ff';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI*2);
                ctx.fill();

                if (this.beamState === 'WARNING' || this.beamState === 'FIRE') {
                    ctx.restore(); 
                    ctx.save();
                    ctx.translate(this.pos.x, this.pos.y);
                    
                    ctx.rotate(this.effectiveBeamAngle);
                    
                    let beamOpacity = this.beamState === 'FIRE' ? 0.8 : 0.2; 
                    let beamColor = `rgba(100, 200, 255, ${beamOpacity})`;

                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(2000, 0); 
                    ctx.moveTo(0,0);
                    ctx.lineTo(-2000, 0); 
                    
                    ctx.strokeStyle = beamColor;
                    ctx.lineWidth = 10;
                    ctx.stroke();
                    
                    ctx.restore(); 
                }
            }
            else if (this.type === 3) { // Supernova
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#d63031';
                ctx.fillStyle = `rgba(255, ${Math.random()*100}, 0, 1)`;
                ctx.beginPath();
                ctx.arc(0, 0, this.visualRadius * 0.6, 0, Math.PI*2);
                ctx.fill();
            }
            else if (this.type === 4) { // Black Hole
                ctx.shadowBlur = 50;
                ctx.shadowColor = '#ffffff'; 
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, (this.radius * 0.5) + 5, 0, Math.PI*2);
                ctx.stroke();

                ctx.shadowBlur = 0;
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI*2);
                ctx.fill();
            }

            ctx.restore();
        }
    }

    class Projectile {
        constructor(x, y, angle) {
            this.pos = new Vector(x, y);
            let speed = 6 * GAME_SPEED_MULTIPLIER;
            this.vel = new Vector(Math.cos(angle)*speed, Math.sin(angle)*speed);
            this.radius = 6;
            // --- CHANGED: LONGER LIFE ---
            this.life = 180 / GAME_SPEED_MULTIPLIER; 
        }
        update() {
            this.pos.add(this.vel);
            this.life--;
        }
        draw() {
            ctx.fillStyle = '#b2bec3';
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
            ctx.fill();
        }
    }

    class Particle {
        constructor(x, y, vx, vy, color, life) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(vx, vy);
            this.color = color;
            this.life = life / GAME_SPEED_MULTIPLIER; 
            this.maxLife = this.life;
        }
        update() {
            this.pos.add(this.vel);
            this.life--;
        }
        draw() {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    // --- Systems ---
    
    function applyCentralGravity(obj) {
        if (obj.type < 1 || obj.dead) return; 

        let center = new Vector(width / 2, height / 2);
        let dx = center.x - obj.pos.x;
        let dy = center.y - obj.pos.y;
        
        let dirToCenter = new Vector(dx, dy);
        dirToCenter.normalize();

        let gravityForce = 0.02 * GAME_SPEED_MULTIPLIER; 
        
        dirToCenter.mult(gravityForce);
        obj.vel.add(dirToCenter);
    }

    function applyLocalGravity(target) {
        if (target.dead) return;

        for (let entity of entities) {
            if (entity === target) continue; 
            if (entity.type < 1 || entity.type === 4) continue;
            
            let dx = entity.pos.x - target.pos.x;
            let dy = entity.pos.y - target.pos.y;
            let distSq = dx*dx + dy*dy;
            
            if (distSq > 360000) continue; 

            let forceMagnitude = (entity.mass * 50) / distSq;
            
            if (forceMagnitude > 0.15) forceMagnitude = 0.15; 

            if (target.type >= 1 && entity.type >= 1) {
                forceMagnitude *= 3.0;
            }

            // --- SHIP 1: ANCHOR RESISTANCE ---
            if (target === player && player.shipType === 1) {
                forceMagnitude *= 0.75; 
            }

            let pull = new Vector(dx, dy);
            pull.normalize();
            pull.mult(forceMagnitude * GAME_SPEED_MULTIPLIER);

            target.vel.add(pull);
        }
    }

    function applyBlackHoleGravity(target) {
        if (target.dead) return;

        for (let bh of entities.filter(e => e.type === 4)) {
            if (bh === target) continue;

            let dx = bh.pos.x - target.pos.x;
            let dy = bh.pos.y - target.pos.y;
            let distSq = dx*dx + dy*dy;
            
            let forceStrength = bh.radius * 1000; 

            let force = (forceStrength / distSq) * GAME_SPEED_MULTIPLIER; 
            if (force > 10 * GAME_SPEED_MULTIPLIER) force = 10 * GAME_SPEED_MULTIPLIER;

            // --- SHIP 1: ANCHOR RESISTANCE ---
            if (target === player && player.shipType === 1) {
                force *= 0.75;
            }
            
            let pull = new Vector(dx, dy);
            pull.normalize();
            pull.mult(force);

            target.vel.add(pull);
        }
    }

    function spawnEntity() {
        let x, y;
        if (Math.random() < 0.5) {
            x = Math.random() < 0.5 ? -50 : width + 50;
            y = Math.random() * height;
        } else {
            x = Math.random() * width;
            y = Math.random() < 0.5 ? -50 : height + 50;
        }
        entities.push(new Entity(x, y, 15 + Math.random()*15, 0));
    }

    function checkCollisions() {
        // Player vs Entity
        for (let e of entities) {
            let dx = player.pos.x - e.pos.x;
            let dy = player.pos.y - e.pos.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            let visualRadius = e.getVisualRadius();

            // --- SHIP 3: PHANTOM INTANGIBILITY ---
            if (player.shipType === 3 && player.abilityActive) continue;

            if (e.type === 4) {
                if (dist < visualRadius + player.radius) {
                    // Protected by shield (Ship 0)
                    if (!(player.shipType === 0 && player.abilityActive)) { 
                        gameOver("Swallowed by Black Hole");
                    }
                }
            } else {
                if (dist < player.radius + visualRadius) {
                    if (!(player.shipType === 0 && player.abilityActive)) {
                        gameOver(`Crashed into a ${getTypeName(e.type)}`);
                    } else {
                        // Shield Bump
                        let pushDir = new Vector(e.pos.x - player.pos.x, e.pos.y - player.pos.y);
                        pushDir.normalize();
                        pushDir.mult(5);
                        e.vel.add(pushDir);
                    }
                }
            }
        }

        // Projectile vs Player
        for (let p of projectiles) {
            let dx = player.pos.x - p.pos.x;
            let dy = player.pos.y - p.pos.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                
                // Check Invincibility (Ship 0) or Phase (Ship 3)
                let isProtected = (player.shipType === 0 && player.abilityActive) || (player.shipType === 3 && player.abilityActive);
                
                if (!isProtected) {
                    gameOver("Hit by Supernova Debris");
                }
            }
        }

        // Entity vs Entity
        for (let i = 0; i < entities.length; i++) {
            for (let j = i + 1; j < entities.length; j++) {
                let e1 = entities[i];
                let e2 = entities[j];
                
                if(e1.markedForDeletion || e2.markedForDeletion) continue;

                let dx = e1.pos.x - e2.pos.x;
                let dy = e1.pos.y - e2.pos.y;
                let dist = Math.sqrt(dx*dx + dy*dy);
                let visualDist = e1.getVisualRadius() + e2.getVisualRadius();

                if (dist < visualDist) {
                    
                    if (e1.type === 4 && e2.type !== 4) {
                        e2.markedForDeletion = true;
                        e1.radius += 1; 
                        continue;
                    }
                    if (e2.type === 4 && e1.type !== 4) {
                        e1.markedForDeletion = true;
                        e2.radius += 1; 
                        continue;
                    }

                    if (e1.type === 0 && e2.type === 0) {
                        e1.markedForDeletion = true;
                        e2.markedForDeletion = true;
                        let midX = (e1.pos.x + e2.pos.x) / 2;
                        let midY = (e1.pos.y + e2.pos.y) / 2;
                        let newRadius = e1.radius + e2.radius * 0.5;
                        entities.push(new Entity(midX, midY, newRadius, 0));
                    } else {
                        if (e1.radius > e2.radius) {
                            e1.radius += e2.radius * 0.2; 
                            e2.markedForDeletion = true;
                        } else {
                            e2.radius += e1.radius * 0.2; 
                            e1.markedForDeletion = true;
                        }
                    }
                }
            }
        }
    }

    function getTypeName(type) {
        return ["Asteroid", "Star", "Pulsar", "Supernova", "Black Hole"][type];
    }

    function gameOver(reason) {
        if (!gameRunning) return;
        gameRunning = false;
        player.dead = true; 
        document.getElementById('game-over').style.display = 'block';
        document.getElementById('death-reason').innerText = reason;
        document.getElementById('final-score').innerText = document.getElementById('score').innerText;
    }

    function startGame(type) {
        document.getElementById('menu').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        
        entities = [];
        particles = [];
        projectiles = [];
        
        lastShipType = type; // Remember selection
        player = new Player(type);
        startTime = Date.now();
        gameState = 'PLAYING';
        gameRunning = true;
    }

    // --- CHANGED: NEW RESTART FUNCTION ---
    function restartGame() {
        document.getElementById('game-over').style.display = 'none';
        startGame(lastShipType);
    }

    function resetMenu() {
        document.getElementById('game-over').style.display = 'none';
        document.getElementById('ui').style.display = 'none';
        document.getElementById('menu').style.display = 'flex';
        gameState = 'MENU';
        gameRunning = true; 
    }

    // --- Main Loop ---

    function init() {
        resize();
        window.addEventListener('resize', resize);
        
        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        for(let i=0; i<100; i++) {
            starsBg.push({
                x: Math.random() * window.innerWidth, 
                y: Math.random() * window.innerHeight, 
                s: Math.random() * 2
            });
        }
        
        player = new Player(0); 

        loop();
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }

    function loop() {
        requestAnimationFrame(loop);

        ctx.fillStyle = '#050505';
        ctx.fillRect(0, 0, width, height);

        ctx.fillStyle = 'white';
        for(let s of starsBg) {
            ctx.fillRect(s.x, s.y, s.s, s.s);
        }

        if (gameState === 'MENU') {
            return; 
        }

        if (!gameRunning) return;

        let elapsed = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById('score').innerText = `Time Survived: ${elapsed}s`;

        if (Math.random() < 0.04 * GAME_SPEED_MULTIPLIER) spawnEntity(); 

        entities.forEach(applyCentralGravity);
        applyLocalGravity(player);
        entities.forEach(applyLocalGravity); 
        applyBlackHoleGravity(player);
        entities.forEach(applyBlackHoleGravity);

        player.update();
        player.draw();

        entities.forEach(e => e.update());
        entities = entities.filter(e => !e.markedForDeletion);
        entities.forEach(e => e.draw());

        projectiles.forEach(p => p.update());
        projectiles = projectiles.filter(p => p.life > 0);
        projectiles.forEach(p => p.draw());

        particles.forEach(p => p.update());
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => p.draw());

        checkCollisions();
    }

    init();

</script>
</body>
</html>
